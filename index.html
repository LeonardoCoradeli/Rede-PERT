<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ferramenta de Rede de Tarefas (PERT/CPM)</title>
    <!-- 1. Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 2. Bibliotecas de Exportação (FileSaver já estava) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

    <!-- 3. NOVAS Bibliotecas para Gantt PDF -->
    <!-- jsPDF para criar o PDF -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- Chart.js para desenhar o gráfico -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- date-fns e o adapter para Chart.js lidar com datas -->
    <script src="https://cdn.jsdelivr.net/npm/date-fns/cdn.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>

    <style id="pert-svg-styles">
        /* Estilos customizados para o SVG */
        body { font-family: 'Inter', sans-serif; }
        .node {
            transition: all 0.2s ease;
            stroke-width: 2px;
        }
        .node.selected {
            fill: #ebf8ff; /* Azul claro */
            stroke: #2b6cb0; /* Azul escuro */
            stroke-width: 3px;
        }
        .node-text {
            font-size: 10px;
            fill: #333;
            pointer-events: none;
            user-select: none;
        }
        .node-es-ls-text {
            font-size: 10px;
            font-family: monospace;
            fill: #000;
            pointer-events: none;
            user-select: none;
        }
        .task-line {
            stroke: #4a5568;
            stroke-width: 2;
            marker-end: url(#arrowhead);
        }
        .task-text {
            font-size: 11px;
            fill: #2d3748;
            pointer-events: none;
            user-select: none;
            text-shadow: 0 0 3px #fff, 0 0 3px #fff, 0 0 3px #fff;
        }
        .start-node {
            fill: #c6f6d5; /* Verde */
            stroke: #38a169;
        }
        .end-node {
            fill: #fed7d7; /* Vermelho */
            stroke: #c53030;
        }
        .critical-path-node {
            stroke: #c53030; /* Vermelho */
            stroke-width: 4px;
        }
        .critical-path-task {
            stroke: #c53030; /* Vermelho */
            stroke-width: 3;
        }
        .node:hover {
            transform: scale(1.1);
        }
    </style>
</head>
<body class="bg-gray-100 flex h-screen overflow-hidden">

    <!-- Barra de Ferramentas Lateral -->
    <div class="w-64 bg-white shadow-lg p-4 overflow-y-auto space-y-3">
        <h1 class="text-xl font-bold text-gray-800">Rede de Tarefas</h1>
        
        <!-- Status Atual -->
        <div>
            <label class="text-xs font-semibold text-gray-500 uppercase">Modo</label>
            <p id="status-text" class="text-blue-600 font-medium">Visualizando</p>
        </div>

        <!-- Ações de Edição -->
        <fieldset class="border-t pt-3">
            <legend class="text-sm font-semibold text-gray-600">Editar</legend>
            <div class="grid grid-cols-2 gap-2 mt-2">
                <button id="add-node-btn" class="p-2 bg-blue-500 text-white rounded-lg shadow hover:bg-blue-600 transition">Evento (Nó)</button>
                <button id="add-task-btn" class="p-2 bg-green-500 text-white rounded-lg shadow hover:bg-green-600 transition">Tarefa (Seta)</button>
            </div>
            <div class="grid grid-cols-2 gap-2 mt-2">
                <button id="view-mode-btn" class="p-2 bg-gray-500 text-white rounded-lg shadow hover:bg-gray-600 transition">Visualizar</button>
                <button id="clear-btn" class="p-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 transition">Limpar Tudo</button>
            </div>
        </fieldset>

        <!-- Ações de Cálculo -->
        <fieldset class="border-t pt-3">
            <legend class="text-sm font-semibold text-gray-600">Calcular</legend>
            
            <!-- NOVO: Input de Data de Início -->
            <div class="mt-2">
                <label for="start-date-input" class="block text-sm font-medium text-gray-700">Data de Início</label>
                <input type="date" id="start-date-input" value="2025-08-04" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500">
            </div>

            <div class="grid grid-cols-2 gap-2 mt-2">
                <button id="set-start-btn" class="p-2 bg-indigo-500 text-white rounded-lg shadow hover:bg-indigo-600 transition">Definir Início</button>
                <button id="set-end-btn" class="p-2 bg-purple-500 text-white rounded-lg shadow hover:bg-purple-600 transition">Definir Fim</button>
            </div>
            <button id="calculate-btn" class="w-full mt-2 p-2 bg-red-500 text-white rounded-lg shadow font-bold hover:bg-red-600 transition">Calcular Caminho</button>
        </fieldset>

        <!-- Importar / Exportar -->
        <fieldset class="border-t pt-3">
            <legend class="text-sm font-semibold text-gray-600">Projeto</legend>
            <div class="grid grid-cols-2 gap-2 mt-2">
                <button id="import-json-btn" class="p-2 bg-gray-700 text-white rounded-lg shadow hover:bg-gray-800 transition">Importar JSON</button>
                <button id="export-json-btn" class="p-2 bg-gray-700 text-white rounded-lg shadow hover:bg-gray-800 transition">Exportar JSON</button>
                <input type="file" id="file-input" class="hidden" accept=".json">
            </div>
        </fieldset>
        
        <!-- Exportar Imagem / PDF -->
        <fieldset class="border-t pt-3">
            <legend class="text-sm font-semibold text-gray-600">Exportar Imagem</legend>
            <div class="grid grid-cols-1 gap-2 mt-2">
                <button id="export-svg-btn" class="p-2 bg-teal-500 text-white rounded-lg shadow hover:bg-teal-600 transition">Exportar SVG</button>
                <!-- NOVO: Botão Exportar Gantt PDF -->
                <button id="export-gantt-pdf-btn" class="p-2 bg-cyan-600 text-white rounded-lg shadow hover:bg-cyan-700 transition">Exportar Gantt (PDF)</button>
            </div>
        </fieldset>
    </div>

    <!-- Área de Desenho Principal -->
    <div class="flex-1 bg-gray-200 p-4">
        <div class="w-full h-full bg-white rounded-lg shadow-inner overflow-hidden">
            <svg id="diagram-svg" class="w-full h-full cursor-crosshair">
                <defs>
                    <!-- Definição da ponta da seta -->
                    <marker
                        id="arrowhead"
                        markerWidth="10"
                        markerHeight="7"
                        refX="9"
                        refY="3.5"
                        orient="auto">
                        <polygon points="0 0, 10 3.5, 0 7" fill="#4a5568" />
                    </marker>
                    <marker
                        id="arrowhead-critical"
                        markerWidth="10"
                        markerHeight="7"
                        refX="9"
                        refY="3.5"
                        orient="auto">
                        <polygon points="0 0, 10 3.5, 0 7" fill="#c53030" />
                    </marker>
                </defs>
                <!-- O conteúdo do diagrama (nós, setas) será injetado aqui pelo JS -->
            </svg>
        </div>
    </div>

    <!-- Modal para Adicionar Tarefa (Oculto) -->
    <div id="task-modal" class="fixed inset-0 bg-gray-900 bg-opacity-50 flex items-center justify-center hidden">
        <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-sm">
            <h3 class="text-lg font-bold mb-4">Adicionar Tarefa</h3>
            <form id="task-form">
                <div class="mb-4">
                    <label for="task-name" class="block text-sm font-medium text-gray-700">Nome da Tarefa</label>
                    <input type="text" id="task-name" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500" required>
                </div>
                <div class="mb-4">
                    <label for="task-time" class="block text-sm font-medium text-gray-700">Tempo (ex: 5)</label>
                    <input type="number" id="task-time" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500" min="0" required>
                </div>
                <div class="flex justify-end space-x-2">
                    <button type="button" id="cancel-task-btn" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300">Cancelar</button>
                    <button type="submit" class="px-4 py-2 bg-green-500 text-white rounded-md hover:bg-green-600">Salvar</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Script Principal da Aplicação -->
    <script type="module">
        // --- Elementos DOM ---
        const svg = document.getElementById('diagram-svg');
        const statusText = document.getElementById('status-text');
        const taskModal = document.getElementById('task-modal');
        const taskForm = document.getElementById('task-form');
        const taskNameInput = document.getElementById('task-name');
        const taskTimeInput = document.getElementById('task-time');
        const fileInput = document.getElementById('file-input');
        // NOVO: Input de data
        const startDateInput = document.getElementById('start-date-input');

        const NODE_RADIUS = 25;

        // --- Estado da Aplicação ---
        // (nodes, tasks, etc. são acessíveis globalmente dentro deste módulo)
        let nodes = []; // { id, x, y, text, es (cedo), ls (tarde) }
        let tasks = []; // { id, from, to, name, time, slack, isCritical }
        let nextNodeId = 1;
        let nextTaskId = 1;

        let currentMode = 'view'; // 'add-node', 'add-task-start', ...
        let tempTaskStartNodeId = null;
        let startNodeId = null;
        let endNodeId = null;

        let isDragging = false;
        let draggedNodeId = null;
        
        let selectedNodeIds = new Set();
        let isSelecting = false; 
        let selectionBoxStart = { x: 0, y: 0 };
        let selectionBoxElement = null;
        
        let dragStartPoint = { x: 0, y: 0 };
        let originalNodePositions = new Map();
        let didDrag = false; 

        let viewTransform = {
            scale: 1,
            translateX: 0,
            translateY: 0
        };
        let isPanning = false;
        let panStartPoint = { x: 0, y: 0 };


        // --- Funções de Renderização (seu código original) ---
        function render() {
            while (svg.lastChild && svg.lastChild.tagName !== 'defs') {
                svg.removeChild(svg.lastChild);
            }

            const viewportGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            viewportGroup.setAttribute('id', 'viewport-group');
            viewportGroup.setAttribute('transform', `translate(${viewTransform.translateX}, ${viewTransform.translateY}) scale(${viewTransform.scale})`);
            svg.appendChild(viewportGroup);

            tasks.forEach(task => {
                const fromNode = nodes.find(n => n.id === task.from);
                const toNode = nodes.find(n => n.id === task.to);
                if (!fromNode || !toNode) return;

                const dx = toNode.x - fromNode.x;
                const dy = toNode.y - fromNode.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist === 0) return; 

                const ratio = (dist - NODE_RADIUS) / dist;
                const targetX = fromNode.x + dx * ratio;
                const targetY = fromNode.y + dy * ratio;

                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', fromNode.x);
                line.setAttribute('y1', fromNode.y);
                line.setAttribute('x2', targetX); 
                line.setAttribute('y2', targetY); 
                line.classList.add('task-line');
                
                if (task.isCritical) {
                    line.classList.add('critical-path-task');
                    line.setAttribute('marker-end', 'url(#arrowhead-critical)');
                } else {
                    line.setAttribute('marker-end', 'url(#arrowhead)');
                }
                viewportGroup.appendChild(line);

                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                const midX = (fromNode.x + toNode.x) / 2;
                const midY = (fromNode.y + toNode.y) / 2;
                text.setAttribute('x', midX);
                text.setAttribute('y', midY);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('dy', '0.3em'); 
                text.classList.add('task-text');
                text.textContent = `${task.name} (${task.time})`;
                viewportGroup.appendChild(text);
            });

            nodes.forEach(node => {
                const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                group.setAttribute('transform', `translate(${node.x}, ${node.y})`);
                group.dataset.id = node.id;

                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('r', NODE_RADIUS);
                circle.classList.add('node');
                
                circle.style.fill = ''; 
                circle.style.stroke = '';
                
                if (node.id === startNodeId) circle.classList.add('start-node');
                if (node.id === endNodeId) circle.classList.add('end-node');
                if (node.isCritical) circle.classList.add('critical-path-node');
                if (selectedNodeIds.has(node.id)) circle.classList.add('selected');
                
                if (node.id !== startNodeId && node.id !== endNodeId && !selectedNodeIds.has(node.id)) {
                    circle.style.fill = '#e2e8f0';
                    circle.style.stroke = '#718096';
                }
                group.appendChild(circle);

                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('dy', '0.3em'); 
                text.classList.add('node-text');
                text.textContent = node.text;
                group.appendChild(text);

                const eslsText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                eslsText.setAttribute('text-anchor', 'middle');
                eslsText.setAttribute('y', -NODE_RADIUS - 5); 
                eslsText.classList.add('node-es-ls-text');
                
                const esText = node.es | 0;
                const lsText = node.ls === Infinity ? 'Inf' : (node.ls | 0);
                let slackText = 'Inf';
                if (node.ls !== Infinity && node.es !== Infinity) {
                    const slack = Math.round(node.ls - node.es);
                    slackText = slack;
                }
                eslsText.textContent = `[${lsText} | ${esText}] = ${slackText}`;
                
                group.appendChild(eslsText);
                viewportGroup.appendChild(group);
            });
        }

        // --- Funções de Lógica de UI (seu código original) ---
        function setMode(newMode) {
            currentMode = newMode;
            if (newMode !== 'view') {
                selectedNodeIds.clear();
                render();
            }
            
            switch (newMode) {
                case 'view':
                    statusText.textContent = 'Visualizando (Shift+Click: Seleção, Alt+Drag: Mover)';
                    statusText.className = 'font-medium text-gray-700';
                    svg.style.cursor = 'grab';
                    break;
                case 'add-node':
                    statusText.textContent = 'Clique para adicionar um Evento (Nó)';
                    statusText.className = 'font-medium text-blue-600';
                    svg.style.cursor = 'copy';
                    break;
                case 'add-task-start':
                    statusText.textContent = 'Clique no nó de INÍCIO da tarefa';
                    statusText.className = 'font-medium text-green-600';
                    svg.style.cursor = 'pointer';
                    break;
                case 'add-task-end':
                    statusText.textContent = 'Clique no nó de FIM da tarefa';
                    statusText.className = 'font-medium text-green-600';
                    svg.style.cursor = 'pointer';
                    break;
                case 'set-start':
                    statusText.textContent = 'Clique no nó que será o INÍCIO do projeto';
                    statusText.className = 'font-medium text-indigo-600';
                    svg.style.cursor = 'pointer';
                    break;
                case 'set-end':
                    statusText.textContent = 'Clique no nó que será o FIM do projeto';
                    statusText.className = 'font-medium text-purple-600';
                    svg.style.cursor = 'pointer';
                    break;
            }
        }
        function showTaskModal() {
            taskModal.classList.remove('hidden');
            taskNameInput.focus();
        }
        function hideTaskModal() {
            taskModal.classList.add('hidden');
            taskForm.reset();
        }
        function getClickedNodeId(target) {
            let el = target;
            while (el && el !== svg) {
                if (el.tagName === 'g' && el.dataset.id) {
                    return parseInt(el.dataset.id);
                }
                if ((el.tagName === 'circle' || el.tagName === 'text') && el.parentElement.tagName === 'g' && el.parentElement.dataset.id) {
                    return parseInt(el.parentElement.dataset.id);
                }
                el = el.parentElement;
            }
            return null;
        }
        function deleteNode(nodeId) {
            nodes = nodes.filter(n => n.id !== nodeId);
            tasks = tasks.filter(t => t.from !== nodeId && t.to !== nodeId);
            if (startNodeId === nodeId) startNodeId = null;
            if (endNodeId === nodeId) endNodeId = null;
            selectedNodeIds.delete(nodeId);
            console.log(`Nó ${nodeId} excluído.`);
            render();
        }

        // --- Handlers de Eventos (seu código original) ---
        document.getElementById('add-node-btn').addEventListener('click', () => setMode('add-node'));
        document.getElementById('add-task-btn').addEventListener('click', () => setMode('add-task-start'));
        document.getElementById('view-mode-btn').addEventListener('click', () => setMode('view'));
        document.getElementById('set-start-btn').addEventListener('click', () => setMode('set-start'));
        document.getElementById('set-end-btn').addEventListener('click', () => setMode('set-end'));
        
        document.getElementById('clear-btn').addEventListener('click', () => {
            nodes = [];
            tasks = [];
            startNodeId = null;
            endNodeId = null;
            nextNodeId = 1;
            nextTaskId = 1;
            selectedNodeIds.clear();
            setMode('view');
            render();
        });

        document.getElementById('calculate-btn').addEventListener('click', () => {
            if (calculatePaths()) {
                render();
            }
        });

        svg.addEventListener('mousedown', (e) => {
            if (e.button !== 0) return; 
            didDrag = false; 
            const nodeId = getClickedNodeId(e.target);
            const svgPoint = getSVGPoint(e.clientX, e.clientY);
            
            if (nodeId) {
                if (currentMode === 'view') {
                    isDragging = true; 
                    draggedNodeId = nodeId; 
                    dragStartPoint = svgPoint;
                    
                    if (!e.shiftKey) {
                        if (!selectedNodeIds.has(nodeId)) {
                            selectedNodeIds.clear();
                            selectedNodeIds.add(nodeId);
                        }
                    } else {
                        if (selectedNodeIds.has(nodeId)) {
                            selectedNodeIds.delete(nodeId);
                        } else {
                            selectedNodeIds.add(nodeId);
                        }
                    }
                    originalNodePositions.clear();
                    let idsToDrag = selectedNodeIds; 
                    for (const id of idsToDrag) {
                        const n = nodes.find(n => n.id === id);
                        if(n) originalNodePositions.set(id, { x: n.x, y: n.y });
                    }
                    svg.style.cursor = 'grabbing';
                    render();
                } else {
                    if (selectedNodeIds.size > 0) {
                        selectedNodeIds.clear();
                        render();
                    }
                }
            } else if (currentMode === 'view') {
                if (e.altKey) {
                    isPanning = true;
                    panStartPoint = { x: e.clientX, y: e.clientY };
                    svg.style.cursor = 'move';
                } else {
                    isSelecting = true;
                    selectionBoxStart = svgPoint;
                    selectionBoxElement = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    selectionBoxElement.setAttribute('fill', 'rgba(43, 108, 176, 0.2)');
                    selectionBoxElement.setAttribute('stroke', 'rgba(43, 108, 176, 0.5)');
                    selectionBoxElement.setAttribute('stroke-width', '1');
                    svg.appendChild(selectionBoxElement);
                    
                    if (!e.shiftKey) {
                        selectedNodeIds.clear();
                        render();
                    }
                }
            }
        });
        
        svg.addEventListener('mousemove', (e) => {
            if (isDragging) {
                didDrag = true; 
                const svgPoint = getSVGPoint(e.clientX, e.clientY);
                const dx = svgPoint.x - dragStartPoint.x;
                const dy = svgPoint.y - dragStartPoint.y;
                
                for (const [id, originalPos] of originalNodePositions.entries()) {
                    const node = nodes.find(n => n.id === id);
                    if (node) {
                        node.x = originalPos.x + dx;
                        node.y = originalPos.y + dy;
                    }
                }
                render();
            } else if (isPanning) {
                didDrag = true;
                const dx = e.clientX - panStartPoint.x;
                const dy = e.clientY - panStartPoint.y;
                viewTransform.translateX += dx;
                viewTransform.translateY += dy;
                panStartPoint = { x: e.clientX, y: e.clientY }; 
                const viewportGroup = document.getElementById('viewport-group');
                if(viewportGroup) {
                    viewportGroup.setAttribute('transform', `translate(${viewTransform.translateX}, ${viewTransform.translateY}) scale(${viewTransform.scale})`);
                }
            } else if (isSelecting) {
                didDrag = true; 
                const svgPoint = getSVGPoint(e.clientX, e.clientY);
                const x = Math.min(selectionBoxStart.x, svgPoint.x);
                const y = Math.min(selectionBoxStart.y, svgPoint.y);
                const width = Math.abs(selectionBoxStart.x - svgPoint.x);
                const height = Math.abs(selectionBoxStart.y - svgPoint.y);
                selectionBoxElement.setAttribute('x', x);
                selectionBoxElement.setAttribute('y', y);
                selectionBoxElement.setAttribute('width', width);
                selectionBoxElement.setAttribute('height', height);
            }
        });
        
        svg.addEventListener('mouseup', (e) => {
            if (isDragging) {
                isDragging = false;
                draggedNodeId = null;
                originalNodePositions.clear();
                setMode(currentMode);
            } else if (isPanning) {
                isPanning = false;
                setMode('view'); 
            } else if (isSelecting) {
                isSelecting = false;
                const x = parseFloat(selectionBoxElement.getAttribute('x'));
                const y = parseFloat(selectionBoxElement.getAttribute('y'));
                const width = parseFloat(selectionBoxElement.getAttribute('width'));
                const height = parseFloat(selectionBoxElement.getAttribute('height'));
                
                nodes.forEach(node => {
                    if (node.x > x && node.x < (x + width) && node.y > y && node.y < (y + height)) {
                        selectedNodeIds.add(node.id);
                    }
                });
                
                selectionBoxElement.remove();
                selectionBoxElement = null;
                render(); 
            }
        });

        svg.addEventListener('contextmenu', (e) => {
            e.preventDefault(); 
            const nodeId = getClickedNodeId(e.target);
            if (nodeId) {
                deleteNode(nodeId);
            }
        });

        svg.addEventListener('click', (e) => {
            if (didDrag) {
                didDrag = false; 
                return;
            }
            const svgPoint = getSVGPoint(e.clientX, e.clientY);
            const clickedNodeId = getClickedNodeId(e.target);
            switch (currentMode) {
                case 'add-node':
                    if (clickedNodeId) return; 
                    nodes.push({
                        id: nextNodeId,
                        x: svgPoint.x,
                        y: svgPoint.y,
                        text: `E${nextNodeId}`,
                        es: 0,
                        ls: 0,
                        isCritical: false,
                    });
                    nextNodeId++;
                    render();
                    break;
                case 'add-task-start':
                    if (clickedNodeId) {
                        tempTaskStartNodeId = clickedNodeId;
                        setMode('add-task-end');
                    }
                    break;
                case 'add-task-end':
                    if (clickedNodeId && clickedNodeId !== tempTaskStartNodeId) {
                        taskForm.dataset.from = tempTaskStartNodeId;
                        taskForm.dataset.to = clickedNodeId;
                        showTaskModal();
                    } else {
                        setMode('add-task-start');
                    }
                    tempTaskStartNodeId = null;
                    break;
                case 'set-start':
                    if (clickedNodeId) {
                        startNodeId = clickedNodeId;
                        setMode('view');
                        render();
                    } else {
                        setMode('view');
                    }
                    break;
                case 'set-end':
                    if (clickedNodeId) {
                        endNodeId = clickedNodeId;
                        setMode('view');
                        render();
                    } else {
                        setMode('view');
                    }
                    break;
                case 'view':
                    if (!clickedNodeId && !e.shiftKey) {
                        selectedNodeIds.clear();
                        render();
                    }
                    break;
            }
        });

        taskForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const from = parseInt(taskForm.dataset.from);
            const to = parseInt(taskForm.dataset.to);
            const name = taskNameInput.value;
            const time = parseFloat(taskTimeInput.value);

            if (from && to && name && time >= 0) {
                tasks.push({
                    id: nextTaskId++,
                    from: from,
                    to: to,
                    name: name,
                    time: time,
                    slack: 0,
                    isCritical: false
                });
                hideTaskModal();
                setMode('add-task-start');
                render();
            }
        });

        document.getElementById('cancel-task-btn').addEventListener('click', () => {
            hideTaskModal();
            setMode('add-task-start');
        });
        
        function getSVGPoint(clientX, clientY) {
            const viewportGroup = document.getElementById('viewport-group');
            const pt = svg.createSVGPoint();
            pt.x = clientX;
            pt.y = clientY;
            if (!viewportGroup) {
                return pt.matrixTransform(svg.getScreenCTM().inverse());
            }
            return pt.matrixTransform(viewportGroup.getScreenCTM().inverse());
        }

        svg.addEventListener('wheel', (e) => {
            e.preventDefault(); 
            if (currentMode !== 'view') return; 

            const viewportGroup = document.getElementById('viewport-group');
            if (!viewportGroup) return;

            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1; 
            const oldScale = viewTransform.scale;
            
            viewTransform.scale = Math.max(0.1, Math.min(5, viewTransform.scale * zoomFactor)); 
            
            const worldPoint = getSVGPoint(e.clientX, e.clientY);

            viewTransform.translateX = worldPoint.x - (worldPoint.x - viewTransform.translateX) * (viewTransform.scale / oldScale);
            viewTransform.translateY = worldPoint.y - (worldPoint.y - viewTransform.translateY) * (viewTransform.scale / oldScale);
            
            viewportGroup.setAttribute('transform', `translate(${viewTransform.translateX}, ${viewTransform.translateY}) scale(${viewTransform.scale})`);
        });

        // --- Lógica de Cálculo (CPM) (seu código original) ---
        function calculatePaths() {
            if (!startNodeId || !endNodeId) {
                console.error("Por favor, defina um nó de INÍCIO e um nó de FIM antes de calcular.");
                return false;
            }

            nodes.forEach(n => {
                n.es = 0;
                n.ls = Infinity; 
                n.isCritical = false;
            });
            tasks.forEach(t => t.isCritical = false);

            const startNode = nodes.find(n => n.id === startNodeId);
            const endNode = nodes.find(n => n.id === endNodeId);
            
            // --- 1. Forward Pass (Cálculo do Tempo Cedo - ES) ---
            let nodePredecessors = {}; 
            nodes.forEach(n => {
                nodePredecessors[n.id] = tasks.filter(t => t.to === n.id).length;
            });
            
            let processQueue = [startNode];
            let visitedCount = 0;
            let safetyCheck = 0;
            
            while(processQueue.length > 0) {
                 // Proteção contra loops infinitos em grafos cíclicos
                safetyCheck++;
                if (safetyCheck > nodes.length * nodes.length) {
                    console.warn("Aviso: Cálculo interrompido, possível ciclo detectado.");
                    break;
                }
                
                const u = processQueue.shift();
                visitedCount++;
                
                const outgoingTasks = tasks.filter(t => t.from === u.id);
                
                for(const task of outgoingTasks) {
                    const v = nodes.find(n => n.id === task.to);
                    if (!v) continue; 
                    
                    const newES = u.es + task.time;
                    
                    if (newES > v.es) {
                        v.es = newES;
                    }
                    
                    nodePredecessors[v.id]--;
                    if(nodePredecessors[v.id] === 0) {
                        processQueue.push(v);
                    }
                }
            }
            
            // --- 2. Backward Pass (Cálculo do Tempo Tarde - LS) ---
            const projectDuration = endNode.es;
            
            // Define LS de todos os nós como a duração total
            // Isso lida com nós inalcançáveis ou desconectados
            nodes.forEach(n => {
                n.ls = projectDuration;
            });

            // Recalcula sucessores para o backward pass
            let nodeSuccessorsCount = {};
            nodes.forEach(n => {
                nodeSuccessorsCount[n.id] = tasks.filter(t => t.from === n.id).length;
            });

            processQueue = [endNode];
            safetyCheck = 0;
            
            while(processQueue.length > 0) {
                 // Proteção contra loops
                safetyCheck++;
                if (safetyCheck > nodes.length * nodes.length) {
                    console.warn("Aviso: Cálculo (backward) interrompido, possível ciclo detectado.");
                    break;
                }

                const v = processQueue.shift();
                
                const incomingTasks = tasks.filter(t => t.to === v.id);
                
                for(const task of incomingTasks) {
                    const u = nodes.find(n => n.id === task.from);
                    if (!u) continue;

                    const newLS = v.ls - task.time;
                    
                    if (newLS < u.ls) {
                        u.ls = newLS;
                    }
                    
                    nodeSuccessorsCount[u.id]--;
                    // Só adiciona à fila se todos os caminhos sucessores tiverem sido processados
                    if(nodeSuccessorsCount[u.id] === 0) {
                         if (!processQueue.includes(u)) { // Evita duplicatas
                            processQueue.push(u);
                         }
                    }
                }
            }
            
            // --- 3. Calcular Folga (Slack) e Caminho Crítico ---
            const tolerance = 1e-5; 
            
            nodes.forEach(n => {
                const slack = n.ls - n.es;
                // Um nó é crítico se sua folga é (próxima de) zero
                if (Math.abs(slack) < tolerance) {
                    n.isCritical = true;
                }
            });
            
            tasks.forEach(task => {
                const fromNode = nodes.find(n => n.id === task.from);
                const toNode = nodes.find(n => n.id === task.to);
                if (!fromNode || !toNode) return;

                // Folga da tarefa = LS(fim) - ES(início) - Duração
                const slack = toNode.ls - fromNode.es - task.time;
                task.slack = slack;
                
                // Tarefa é crítica se sua folga é zero E conecta nós críticos
                if (Math.abs(slack) < tolerance && fromNode.isCritical && toNode.isCritical) {
                    task.isCritical = true;
                }
            });
            
            return true;
        }

        // --- Funções de Import/Export (seu código original) ---
        // JSON
        document.getElementById('export-json-btn').addEventListener('click', () => {
            const data = {
                nodes,
                tasks,
                nextNodeId,
                nextTaskId,
                startNodeId,
                endNodeId
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            saveAs(blob, 'projeto-rede-tarefas.json');
        });

        document.getElementById('import-json-btn').addEventListener('click', () => {
            fileInput.click();
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const data = JSON.parse(event.target.result);
                    nodes = data.nodes || [];
                    tasks = data.tasks || [];
                    nextNodeId = data.nextNodeId || 1;
                    nextTaskId = data.nextTaskId || 1;
                    startNodeId = data.startNodeId || null;
                    endNodeId = data.endNodeId || null;
                    selectedNodeIds.clear();
                    // Limpa transformações de pan/zoom
                    viewTransform = { scale: 1, translateX: 0, translateY: 0 };
                    render();
                    setMode('view');
                } catch (err) {
                    console.error("Erro ao ler o arquivo JSON: " + err.message);
                }
            };
            reader.readAsText(file);
            fileInput.value = null;
        });

        // SVG
        function getClonedSvgWithStyles() {
            const clonedSvg = svg.cloneNode(true);
            
            // Define o BBox (bounding box) de todo o conteúdo
            const viewportGroup = clonedSvg.querySelector('#viewport-group');
            let bbox = { x: 0, y: 0, width: 1000, height: 800 }; // Default
            if (viewportGroup && viewportGroup.getBBox) {
                 try {
                    bbox = viewportGroup.getBBox();
                    // Adiciona padding
                    bbox.x -= 50;
                    bbox.y -= 50;
                    bbox.width += 100;
                    bbox.height += 100;
                 } catch(e) {
                    console.warn("Não foi possível calcular o BBox do SVG, usando tamanho padrão.", e);
                 }
            }

            // Remove o transform do grupo para que o viewBox funcione
            if (viewportGroup) {
                viewportGroup.setAttribute('transform', '');
            }
            
            clonedSvg.setAttribute('width', bbox.width);
            clonedSvg.setAttribute('height', bbox.height);
            clonedSvg.setAttribute('viewBox', `${bbox.x} ${bbox.y} ${bbox.width} ${bbox.height}`);
            
            const styleDef = document.createElementNS('http://www.w3.org/2000/svg', 'style');
            const styleElement = document.getElementById('pert-svg-styles');
            if (styleElement) {
                styleDef.textContent = styleElement.innerHTML;
            }
            styleDef.textContent += `
                svg { font-family: 'Inter', sans-serif; }
                .task-text { text-shadow: 0 0 3px #fff, 0 0 3px #fff, 0 0 3px #fff; }
            `;
            clonedSvg.querySelector('defs').appendChild(styleDef);
            return clonedSvg;
        }

        document.getElementById('export-svg-btn').addEventListener('click', () => {
            if (typeof saveAs === 'undefined') {
                console.error("Erro: Biblioteca FileSaver.js não carregada.");
                return;
            }
            const clonedSvg = getClonedSvgWithStyles();
            const svgData = new XMLSerializer().serializeToString(clonedSvg);
            const blob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
            saveAs(blob, 'diagrama-rede.svg');
        });

        // --- ============================================ ---
        // --- NOVO CÓDIGO: EXPORTAÇÃO DE GANTT (PDF) ---
        // --- ============================================ ---

        
        // 2. Helper para agrupar tarefas (Portado do Python)
        function getTaskCategory(taskName) {
            taskName = String(taskName);
            if (taskName.includes("Diagrama de Sequência")) return "Diagrama de Sequência";
            if (taskName.includes("Diagrama de Colaboração")) return "Diagrama de Colaboração";
            if (taskName.includes("Diagrama de Classe")) return "Diagrama de Classe";
            if (taskName.includes("Caso de Uso de Alto Nivel")) return "Modelagem (Caso de Uso)";
            if (taskName.includes("Documento de Casos de Usos Expandidos")) return "Modelagem (Caso de Uso)";
            if (taskName.includes("Modelo Conceitual")) return "Modelagem (Conceitual)";
            if (taskName.includes("Implementação")) return "Implementação";
            if (taskName.includes("Teste Unitário")) return "Testes (Unitários)";
            if (taskName.toLowerCase().includes("teste de sistema")) return "Testes (Sistema)";
            if (taskName.includes("SQA")) return "SQA (Qualidade)";
            if (taskName.includes("Documento de Requisitos")) return "Documentação";
            if (taskName.includes("Coleta de Requisitos")) return "Coleta de Requisitos";
            
            // Fallback
            return taskName.replace(/ \(E\d+-E\d+\)/, '').replace(/ Módulo \d/, '').trim();
        }

        // 3. Função principal de exportação
        async function exportGanttToPdf() {
            // Verifica se os dados necessários existem
            if (!startNodeId || nodes.length === 0 || tasks.length === 0) {
                alert("Por favor, carregue um projeto e calcule os caminhos primeiro.");
                return;
            }
            
            // Pega a data de início do input
            const startDateValue = startDateInput.value;
            if (!startDateValue) {
                alert("Por favor, defina uma Data de Início do projeto.");
                return;
            }
            // new Date(string) pode ser inconsistente, então fazemos o parse manual
            const [year, month, day] = startDateValue.split('-').map(Number);
            const projectStartDate = new Date(year, month - 1, day);

            // --- A. Processar os dados (igual ao Python) ---
            
            // 1. Criar mapa de consulta de 'es' (início mais cedo)
            const nodeStartTimes = new Map(nodes.map(n => [n.id, n.es]));

            // 2. Processar tarefas
            const processedTasks = tasks.map(task => {
                const startDaysOffset = nodeStartTimes.get(task.from);
                const taskDuration = task.time;
                
                // Criar NOVAS instâncias de Date para cada tarefa
                const startDate = new Date(projectStartDate);
                startDate.setDate(startDate.getDate() + startDaysOffset);
                
                const endDate = new Date(startDate);
                endDate.setDate(endDate.getDate() + taskDuration);

                return {
                    name: task.name,
                    category: getTaskCategory(task.name),
                    start: startDate,
                    end: endDate,
                    isCritical: task.isCritical
                };
            });

            // 3. Criar os datasets para o Chart.js
            const categories = [...new Set(processedTasks.map(t => t.category))];
            
            // Ordenar categorias pela data de início mais cedo
            const categorySortMap = new Map();
            categories.forEach(cat => {
                const minStartDate = Math.min(...processedTasks.filter(t => t.category === cat).map(t => t.start.getTime()));
                categorySortMap.set(cat, minStartDate);
            });
            categories.sort((a, b) => categorySortMap.get(a) - categorySortMap.get(b));

            const criticalData = [];
            const nonCriticalData = [];

            processedTasks.forEach(task => {
                const dataPoint = {
                    x: [task.start.getTime(), task.end.getTime()], // Chart.js usa [início, fim]
                    y: task.category, // O 'label' da categoria no eixo Y
                    name: task.name
                };
                if (task.isCritical) {
                    criticalData.push(dataPoint);
                } else {
                    nonCriticalData.push(dataPoint);
                }
            });
            
            // --- B. Configurar o Chart.js ---
            const chartConfig = {
                type: 'bar',
                data: {
                    labels: categories, // Eixo Y
                    datasets: [
                        {
                            label: 'Não Crítico',
                            data: nonCriticalData,
                            backgroundColor: 'rgba(54, 162, 235, 0.7)', // Azul
                            borderColor: 'rgba(54, 162, 235, 1)',
                            borderWidth: 1,
                            barPercentage: 0.6
                        },
                        {
                            label: 'Crítico',
                            data: criticalData,
                            backgroundColor: 'rgba(255, 99, 132, 0.7)', // Vermelho
                            borderColor: 'rgba(255, 99, 132, 1)',
                            borderWidth: 1,
                            barPercentage: 0.6
                        }
                    ]
                },
                options: {
                    indexAxis: 'y', // Isso torna o gráfico de barras horizontal
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: `Cronograma do Projeto (Início: ${projectStartDate.toLocaleDateString('pt-BR')})`,
                            font: { size: 18 }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const raw = context.raw;
                                    const taskName = raw.name || context.dataset.label;
                                    const start = new Date(raw.x[0]).toLocaleDateString('pt-BR');
                                    const end = new Date(raw.x[1]).toLocaleDateString('pt-BR');
                                    return `${taskName}: ${start} - ${end}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time', // Eixo X é de tempo
                            time: {
                                unit: 'week', // Agrupado por semana
                                displayFormats: {
                                    week: 'dd-MMM-yy'
                                }
                            },
                            min: projectStartDate.getTime(), // Início do gráfico
                            title: {
                                display: true,
                                text: 'Datas (Início da Semana)'
                            },
                            grid: {
                                display: true
                            }
                        },
                        y: {
                            stacked: true, // Agrupa as categorias
                            title: {
                                display: true,
                                text: 'Categorias de Tarefa'
                            },
                            grid: {
                                display: false
                            }
                        }
                    }
                }
            };
            
            // --- C. Desenhar em Canvas Off-screen e Exportar para PDF ---
            
            // Define o tamanho (Paisagem) - 16:9
            const chartWidth = 1600;
            // Altura dinâmica baseada no número de categorias
            const chartHeight = Math.max(600, categories.length * 40 + 150); // 40px por categoria + 150px para eixos/título

            // Cria o canvas temporário
            const offscreenCanvas = document.createElement('canvas');
            offscreenCanvas.width = chartWidth;
            offscreenCanvas.height = chartHeight;
            offscreenCanvas.style.display = 'none';
            document.body.appendChild(offscreenCanvas);
            
            const ctx = offscreenCanvas.getContext('2d');
            
            // Define um fundo branco para o PDF
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, chartWidth, chartHeight);

            // Altera as opções de animação para que possamos capturar a imagem no final
            chartConfig.options.animation = {
                onComplete: () => {
                    try {
                        const imgData = offscreenCanvas.toDataURL('image/png');
                        
                        // Inicializa jsPDF
                        // 'l' = landscape (paisagem)
                        // 'px' = unidades em pixels
                        // [width, height] = tamanho da página
                        const { jsPDF } = window.jspdf;
                        const pdf = new jsPDF({
                            orientation: 'l',
                            unit: 'px',
                            format: [chartWidth, chartHeight]
                        });
                        
                        // Adiciona a imagem ao PDF
                        pdf.addImage(imgData, 'PNG', 0, 0, chartWidth, chartHeight);
                        
                        // Salva o arquivo
                        pdf.save('Gantt_Projeto.pdf');
                        
                    } catch (e) {
                        console.error("Erro ao gerar o PDF:", e);
                        alert("Erro ao gerar o PDF. Verifique o console.");
                    } finally {
                        // Limpa o canvas temporário
                        document.body.removeChild(offscreenCanvas);
                    }
                }
            };

            // Desenha o gráfico
            new Chart(ctx, chartConfig);
        }

        // 4. Conectar o botão
        document.getElementById('export-gantt-pdf-btn').addEventListener('click', exportGanttToPdf);

        // --- ================================== ---
        // --- FIM DO NOVO CÓDIGO DE GANTT ---
        // --- ================================== ---


        // --- Inicialização ---
        setMode('view');
        render();

    </script>
</body>
</html>
