<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ferramenta de Rede de Tarefas (PERT/CPM)</title>
    <!-- 1. Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 2. Bibliotecas de Exportação -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

    <style id="pert-svg-styles">
        /* Estilos customizados para o SVG */
        body { font-family: 'Inter', sans-serif; }
        .node {
            transition: all 0.2s ease;
            stroke-width: 2px;
            /* Cor padrão movida para o render() para permitir seleção */
        }
        /* MUDANÇA: Estilo para nós selecionados */
        .node.selected {
            fill: #ebf8ff; /* Azul claro */
            stroke: #2b6cb0; /* Azul escuro */
            stroke-width: 3px;
        }
        .node-text {
            font-size: 10px;
            fill: #333;
            pointer-events: none;
            user-select: none;
        }
        .node-es-ls-text {
            font-size: 10px;
            font-family: monospace;
            fill: #000;
            pointer-events: none;
            user-select: none;
        }
        .task-line {
            stroke: #4a5568;
            stroke-width: 2;
            marker-end: url(#arrowhead);
        }
        .task-text {
            font-size: 11px;
            fill: #2d3748;
            pointer-events: none;
            user-select: none;
            text-shadow: 0 0 3px #fff, 0 0 3px #fff, 0 0 3px #fff; /* Sombra mais forte */
        }
        .start-node {
            fill: #c6f6d5; /* Verde */
            stroke: #38a169;
        }
        .end-node {
            fill: #fed7d7; /* Vermelho */
            stroke: #c53030;
        }
        .critical-path-node {
            stroke: #c53030; /* Vermelho */
            stroke-width: 4px;
        }
        .critical-path-task {
            stroke: #c53030; /* Vermelho */
            stroke-width: 3;
        }
        .node:hover {
            transform: scale(1.1);
            /* A cor de hover agora é gerenciada pela seleção */
        }
    </style>
</head>
<body class="bg-gray-100 flex h-screen overflow-hidden">

    <!-- Barra de Ferramentas Lateral -->
    <div class="w-64 bg-white shadow-lg p-4 overflow-y-auto space-y-3">
        <h1 class="text-xl font-bold text-gray-800">Rede de Tarefas</h1>
        
        <!-- Status Atual -->
        <div>
            <label class="text-xs font-semibold text-gray-500 uppercase">Modo</label>
            <p id="status-text" class="text-blue-600 font-medium">Visualizando</p>
        </div>

        <!-- Ações de Edição -->
        <fieldset class="border-t pt-3">
            <legend class="text-sm font-semibold text-gray-600">Editar</legend>
            <div class="grid grid-cols-2 gap-2 mt-2">
                <button id="add-node-btn" class="p-2 bg-blue-500 text-white rounded-lg shadow hover:bg-blue-600 transition">Evento (Nó)</button>
                <button id="add-task-btn" class="p-2 bg-green-500 text-white rounded-lg shadow hover:bg-green-600 transition">Tarefa (Seta)</button>
            </div>
            <div class="grid grid-cols-2 gap-2 mt-2">
                <button id="view-mode-btn" class="p-2 bg-gray-500 text-white rounded-lg shadow hover:bg-gray-600 transition">Visualizar</button>
                <button id="clear-btn" class="p-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 transition">Limpar Tudo</button>
            </div>
        </fieldset>

        <!-- Ações de Cálculo -->
        <fieldset class="border-t pt-3">
            <legend class="text-sm font-semibold text-gray-600">Calcular</legend>
            <div class="grid grid-cols-2 gap-2 mt-2">
                <button id="set-start-btn" class="p-2 bg-indigo-500 text-white rounded-lg shadow hover:bg-indigo-600 transition">Definir Início</button>
                <button id="set-end-btn" class="p-2 bg-purple-500 text-white rounded-lg shadow hover:bg-purple-600 transition">Definir Fim</button>
            </div>
            <button id="calculate-btn" class="w-full mt-2 p-2 bg-red-500 text-white rounded-lg shadow font-bold hover:bg-red-600 transition">Calcular Caminho</button>
        </fieldset>

        <!-- Importar / Exportar -->
        <fieldset class="border-t pt-3">
            <legend class="text-sm font-semibold text-gray-600">Projeto</legend>
            <div class="grid grid-cols-2 gap-2 mt-2">
                <button id="import-json-btn" class="p-2 bg-gray-700 text-white rounded-lg shadow hover:bg-gray-800 transition">Importar JSON</button>
                <button id="export-json-btn" class="p-2 bg-gray-700 text-white rounded-lg shadow hover:bg-gray-800 transition">Exportar JSON</button>
                <input type="file" id="file-input" class="hidden" accept=".json">
            </div>
        </fieldset>
        
        <!-- Exportar Imagem -->
        <fieldset class="border-t pt-3">
            <legend class="text-sm font-semibold text-gray-600">Exportar Imagem</legend>
            <div class="grid grid-cols-1 gap-2 mt-2">
                <button id="export-svg-btn" class="p-2 bg-teal-500 text-white rounded-lg shadow hover:bg-teal-600 transition">Exportar SVG</button>
            </div>
        </fieldset>
    </div>

    <!-- Área de Desenho Principal -->
    <div class="flex-1 bg-gray-200 p-4">
        <div class="w-full h-full bg-white rounded-lg shadow-inner overflow-hidden">
            <svg id="diagram-svg" class="w-full h-full cursor-crosshair">
                <defs>
                    <!-- Definição da ponta da seta -->
                    <marker
                        id="arrowhead"
                        markerWidth="10"
                        markerHeight="7"
                        refX="9"
                        refY="3.5"
                        orient="auto">
                        <polygon points="0 0, 10 3.5, 0 7" fill="#4a5568" />
                    </marker>
                    <marker
                        id="arrowhead-critical"
                        markerWidth="10"
                        markerHeight="7"
                        refX="9"
                        refY="3.5"
                        orient="auto">
                        <polygon points="0 0, 10 3.5, 0 7" fill="#c53030" />
                    </marker>
                </defs>
                <!-- O conteúdo do diagrama (nós, setas) será injetado aqui pelo JS -->
            </svg>
        </div>
    </div>

    <!-- Modal para Adicionar Tarefa -->
    <div id="task-modal" class="fixed inset-0 bg-gray-900 bg-opacity-50 flex items-center justify-center hidden">
        <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-sm">
            <h3 class="text-lg font-bold mb-4">Adicionar Tarefa</h3>
            <form id="task-form">
                <div class="mb-4">
                    <label for="task-name" class="block text-sm font-medium text-gray-700">Nome da Tarefa</label>
                    <input type="text" id="task-name" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500" required>
                </div>
                <div class="mb-4">
                    <label for="task-time" class="block text-sm font-medium text-gray-700">Tempo (ex: 5)</label>
                    <input type="number" id="task-time" class="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500" min="0" required>
                </div>
                <div class="flex justify-end space-x-2">
                    <button type="button" id="cancel-task-btn" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300">Cancelar</button>
                    <button type="submit" class="px-4 py-2 bg-green-500 text-white rounded-md hover:bg-green-600">Salvar</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Script Principal da Aplicação -->
    <script type="module">
        // --- Elementos DOM ---
        const svg = document.getElementById('diagram-svg');
        const statusText = document.getElementById('status-text');
        const taskModal = document.getElementById('task-modal');
        const taskForm = document.getElementById('task-form');
        const taskNameInput = document.getElementById('task-name');
        const taskTimeInput = document.getElementById('task-time');
        const fileInput = document.getElementById('file-input');

        const NODE_RADIUS = 25;

        // --- Estado da Aplicação ---
        let nodes = []; // { id, x, y, text, es (cedo), ls (tarde) }
        let tasks = []; // { id, from, to, name, time, slack, isCritical }
        let nextNodeId = 1;
        let nextTaskId = 1;

        let currentMode = 'view'; // 'add-node', 'add-task-start', 'add-task-end', 'set-start', 'set-end'
        let tempTaskStartNodeId = null;
        let startNodeId = null;
        let endNodeId = null;

        let isDragging = false;
        let draggedNodeId = null;
        
        // MUDANÇA: Variáveis para seleção múltipla
        let selectedNodeIds = new Set();
        let isSelecting = false; // Desenhando caixa de seleção
        let selectionBoxStart = { x: 0, y: 0 };
        let selectionBoxElement = null;
        
        let dragStartPoint = { x: 0, y: 0 };
        let originalNodePositions = new Map();
        let didDrag = false; // Para diferenciar 'drag' de 'click'


        // --- Funções de Renderização ---

        function render() {
            // Limpa o SVG, mas mantém as <defs>
            while (svg.lastChild && svg.lastChild.tagName !== 'defs') {
                svg.removeChild(svg.lastChild);
            }

            // Renderiza Tarefas (Setas) - primeiro para ficarem por baixo
            tasks.forEach(task => {
                const fromNode = nodes.find(n => n.id === task.from);
                const toNode = nodes.find(n => n.id === task.to);
                if (!fromNode || !toNode) return;

                // MUDANÇA: Ajuste para a linha parar na borda do círculo
                const dx = toNode.x - fromNode.x;
                const dy = toNode.y - fromNode.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist === 0) return; // Evita divisão por zero

                const ratio = (dist - NODE_RADIUS) / dist;
                const targetX = fromNode.x + dx * ratio;
                const targetY = fromNode.y + dy * ratio;

                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', fromNode.x);
                line.setAttribute('y1', fromNode.y);
                line.setAttribute('x2', targetX); // MUDANÇA
                line.setAttribute('y2', targetY); // MUDANÇA
                line.classList.add('task-line');
                
                if (task.isCritical) {
                    line.classList.add('critical-path-task');
                    line.setAttribute('marker-end', 'url(#arrowhead-critical)');
                } else {
                    line.setAttribute('marker-end', 'url(#arrowhead)');
                }

                svg.appendChild(line);

                // Texto da Tarefa
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                const midX = (fromNode.x + toNode.x) / 2;
                const midY = (fromNode.y + toNode.y) / 2;
                text.setAttribute('x', midX);
                // MUDANÇA: Alinhamento central
                text.setAttribute('y', midY);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('dy', '0.3em'); // Ajuste vertical
                text.classList.add('task-text');
                text.textContent = `${task.name} (${task.time})`;
                svg.appendChild(text);
            });

            // Renderiza Eventos (Nós)
            nodes.forEach(node => {
                const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                group.setAttribute('transform', `translate(${node.x}, ${node.y})`);
                group.dataset.id = node.id;

                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('r', NODE_RADIUS);
                circle.classList.add('node');
                
                // MUDANÇA: Lógica de classes para estilo
                circle.style.fill = ''; // Reseta estilos inline
                circle.style.stroke = '';
                
                if (node.id === startNodeId) circle.classList.add('start-node');
                if (node.id === endNodeId) circle.classList.add('end-node');
                if (node.isCritical) circle.classList.add('critical-path-node');
                if (selectedNodeIds.has(node.id)) circle.classList.add('selected');
                
                // Aplica cor padrão se nenhuma classe de cor especial se aplicar
                if (node.id !== startNodeId && node.id !== endNodeId && !selectedNodeIds.has(node.id)) {
                    circle.style.fill = '#e2e8f0';
                    circle.style.stroke = '#718096';
                }

                group.appendChild(circle);

                // Texto do ID do Nó
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('dy', '0.3em'); // Centraliza verticalmente
                text.classList.add('node-text');
                text.textContent = node.text;
                group.appendChild(text);

                // Texto ES (Cedo) e LS (Tarde)
                const eslsText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                eslsText.setAttribute('text-anchor', 'middle');
                eslsText.setAttribute('y', -NODE_RADIUS - 5); // Acima do nó
                eslsText.classList.add('node-es-ls-text');
                eslsText.textContent = `[${node.es | 0} | ${node.ls === Infinity ? 'Inf' : (node.ls | 0)}]`;
                group.appendChild(eslsText);

                svg.appendChild(group);
            });
        }

        // --- Funções de Lógica de UI ---

        function setMode(newMode) {
            currentMode = newMode;
            // MUDANÇA: Desseleciona tudo ao trocar de modo
            if (newMode !== 'view') {
                selectedNodeIds.clear();
                render();
            }
            
            switch (newMode) {
                case 'view':
                    statusText.textContent = 'Visualizando (Shift+Click para selecionar)';
                    statusText.className = 'font-medium text-gray-700';
                    svg.style.cursor = 'grab';
                    break;
                case 'add-node':
                    statusText.textContent = 'Clique para adicionar um Evento (Nó)';
                    statusText.className = 'font-medium text-blue-600';
                    svg.style.cursor = 'copy';
                    break;
                case 'add-task-start':
                    statusText.textContent = 'Clique no nó de INÍCIO da tarefa';
                    statusText.className = 'font-medium text-green-600';
                    svg.style.cursor = 'pointer';
                    break;
                case 'add-task-end':
                    statusText.textContent = 'Clique no nó de FIM da tarefa';
                    statusText.className = 'font-medium text-green-600';
                    svg.style.cursor = 'pointer';
                    break;
                case 'set-start':
                    statusText.textContent = 'Clique no nó que será o INÍCIO do projeto';
                    statusText.className = 'font-medium text-indigo-600';
                    svg.style.cursor = 'pointer';
                    break;
                case 'set-end':
                    statusText.textContent = 'Clique no nó que será o FIM do projeto';
                    statusText.className = 'font-medium text-purple-600';
                    svg.style.cursor = 'pointer';
                    break;
            }
        }

        function showTaskModal() {
            taskModal.classList.remove('hidden');
            taskNameInput.focus();
        }

        function hideTaskModal() {
            taskModal.classList.add('hidden');
            taskForm.reset();
        }

        function getClickedNodeId(target) {
            let el = target;
            while (el && el !== svg) {
                if (el.tagName === 'g' && el.dataset.id) {
                    return parseInt(el.dataset.id);
                }
                // Se clicou no círculo ou texto dentro do 'g'
                if ((el.tagName === 'circle' || el.tagName === 'text') && el.parentElement.tagName === 'g' && el.parentElement.dataset.id) {
                    return parseInt(el.parentElement.dataset.id);
                }
                el = el.parentElement;
            }
            return null;
        }

        // MUDANÇA: Função para excluir nó
        function deleteNode(nodeId) {
            nodes = nodes.filter(n => n.id !== nodeId);
            // Deleta tarefas conectadas
            tasks = tasks.filter(t => t.from !== nodeId && t.to !== nodeId);
            
            if (startNodeId === nodeId) startNodeId = null;
            if (endNodeId === nodeId) endNodeId = null;
            selectedNodeIds.delete(nodeId);
            
            console.log(`Nó ${nodeId} excluído.`);
            render();
        }

        // --- Handlers de Eventos ---

        // Handlers dos Botões
        document.getElementById('add-node-btn').addEventListener('click', () => setMode('add-node'));
        document.getElementById('add-task-btn').addEventListener('click', () => setMode('add-task-start'));
        document.getElementById('view-mode-btn').addEventListener('click', () => setMode('view'));
        document.getElementById('set-start-btn').addEventListener('click', () => setMode('set-start'));
        document.getElementById('set-end-btn').addEventListener('click', () => setMode('set-end'));
        
        document.getElementById('clear-btn').addEventListener('click', () => {
            nodes = [];
            tasks = [];
            startNodeId = null;
            endNodeId = null;
            nextNodeId = 1;
            nextTaskId = 1;
            selectedNodeIds.clear();
            setMode('view');
            render();
        });

        document.getElementById('calculate-btn').addEventListener('click', () => {
            if (calculatePaths()) {
                render();
            }
        });

        // MUDANÇA: Handlers do SVG (Mouse) - Lógica de Drag/Seleção
        
        svg.addEventListener('mousedown', (e) => {
            // Ignora botões que não são o principal (ex: direito, do meio)
            if (e.button !== 0) return; 

            didDrag = false; // Reseta o flag de 'drag'
            const nodeId = getClickedNodeId(e.target);
            const svgPoint = getSVGPoint(e.clientX, e.clientY);
            
            if (nodeId) {
                // Clicou num nó
                isDragging = true;
                draggedNodeId = nodeId; // Nó principal
                dragStartPoint = svgPoint;
                
                if (currentMode === 'view') {
                    // Lógica de Seleção Múltipla (Apenas no modo 'view')
                    if (!e.shiftKey) {
                        if (!selectedNodeIds.has(nodeId)) {
                            // Se clicar em um nó não selecionado (sem shift), limpa seleção e seleciona este
                            selectedNodeIds.clear();
                            selectedNodeIds.add(nodeId);
                        }
                        // Se clicou em nó já selecionado, não faz nada (prepara para arrastar o grupo)
                    } else {
                        // Com Shift, alterna a seleção
                        if (selectedNodeIds.has(nodeId)) {
                            selectedNodeIds.delete(nodeId);
                        } else {
                            selectedNodeIds.add(nodeId);
                        }
                    }
                } else {
                    // Em outros modos (add-task, etc.), um clique no nó des-seleciona tudo
                    selectedNodeIds.clear();
                }

                // Armazena posições originais para o drag
                originalNodePositions.clear();
                // Define quais nós arrastar: os selecionados (em view) ou apenas o clicado (outros modos)
                let idsToDrag = (currentMode === 'view' && selectedNodeIds.size > 0) ? selectedNodeIds : new Set([nodeId]);
                
                for (const id of idsToDrag) {
                    const n = nodes.find(n => n.id === id);
                    if(n) originalNodePositions.set(id, { x: n.x, y: n.y });
                }
                
                svg.style.cursor = 'grabbing';
                if (currentMode === 'view') render(); // Atualiza visualização da seleção

            } else if (currentMode === 'view') {
                // Clicou no vazio (inicia selection box), SÓ no modo 'view'
                isSelecting = true;
                selectionBoxStart = svgPoint;
                selectionBoxElement = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                selectionBoxElement.setAttribute('x', svgPoint.x);
                selectionBoxElement.setAttribute('y', svgPoint.y);
                selectionBoxElement.setAttribute('width', 0);
                selectionBoxElement.setAttribute('height', 0);
                selectionBoxElement.style.fill = 'rgba(43, 108, 176, 0.2)';
                selectionBoxElement.style.stroke = '#2b6cb0';
                selectionBoxElement.style.strokeWidth = '1px';
                svg.appendChild(selectionBoxElement);
                
                if (!e.shiftKey) {
                    selectedNodeIds.clear();
                    render();
                }
            }
            // Se clicou no vazio e não está em 'view' mode, o 'click' handler vai cuidar (ex: 'add-node')
        });
        
        svg.addEventListener('mousemove', (e) => {
            if (isDragging) {
                didDrag = true; // Marcou que um 'drag' ocorreu
                const svgPoint = getSVGPoint(e.clientX, e.clientY);
                const dx = svgPoint.x - dragStartPoint.x;
                const dy = svgPoint.y - dragStartPoint.y;
                
                // Move todos os nós que estavam selecionados no mousedown
                for (const [id, originalPos] of originalNodePositions.entries()) {
                    const node = nodes.find(n => n.id === id);
                    if (node) {
                        node.x = originalPos.x + dx;
                        node.y = originalPos.y + dy;
                    }
                }
                render();
            } else if (isSelecting) {
                didDrag = true; // Desenhar um box também conta como 'drag'
                const svgPoint = getSVGPoint(e.clientX, e.clientY);
                const x = Math.min(selectionBoxStart.x, svgPoint.x);
                const y = Math.min(selectionBoxStart.y, svgPoint.y);
                const width = Math.abs(selectionBoxStart.x - svgPoint.x);
                const height = Math.abs(selectionBoxStart.y - svgPoint.y);
                selectionBoxElement.setAttribute('x', x);
                selectionBoxElement.setAttribute('y', y);
                selectionBoxElement.setAttribute('width', width);
                selectionBoxElement.setAttribute('height', height);
            }
        });
        
        svg.addEventListener('mouseup', (e) => {
            if (isDragging) {
                isDragging = false;
                draggedNodeId = null;
                originalNodePositions.clear();
                setMode(currentMode); // Reseta o cursor (ex: de 'grabbing' para 'grab')
            } else if (isSelecting) {
                isSelecting = false;
                // Finaliza a seleção do box
                const x = parseFloat(selectionBoxElement.getAttribute('x'));
                const y = parseFloat(selectionBoxElement.getAttribute('y'));
                const width = parseFloat(selectionBoxElement.getAttribute('width'));
                const height = parseFloat(selectionBoxElement.getAttribute('height'));
                
                nodes.forEach(node => {
                    // Seleciona se o CENTRO do nó está no box
                    if (node.x > x && node.x < (x + width) && node.y > y && node.y < (y + height)) {
                        selectedNodeIds.add(node.id);
                    }
                });
                
                selectionBoxElement.remove();
                selectionBoxElement = null;
                render(); // Mostra a nova seleção
            }
        });

        // MUDANÇA: Adicionado listener de clique direito
        svg.addEventListener('contextmenu', (e) => {
            e.preventDefault(); // Impede o menu do navegador
            const nodeId = getClickedNodeId(e.target);
            if (nodeId) {
                deleteNode(nodeId);
            }
        });

        svg.addEventListener('click', (e) => {
            // MUDANÇA: Ignora 'click' se um 'drag' acabou de acontecer
            if (didDrag) {
                didDrag = false; 
                return;
            }

            const svgPoint = getSVGPoint(e.clientX, e.clientY);
            const clickedNodeId = getClickedNodeId(e.target);

            switch (currentMode) {
                case 'add-node':
                    if (clickedNodeId) return; 
                    nodes.push({
                        id: nextNodeId,
                        x: svgPoint.x,
                        y: svgPoint.y,
                        text: `E${nextNodeId}`,
                        es: 0,
                        ls: 0,
                        isCritical: false,
                    });
                    nextNodeId++;
                    render();
                    break;
                
                case 'add-task-start':
                    if (clickedNodeId) {
                        tempTaskStartNodeId = clickedNodeId;
                        setMode('add-task-end');
                    }
                    break;

                case 'add-task-end':
                    if (clickedNodeId && clickedNodeId !== tempTaskStartNodeId) {
                        taskForm.dataset.from = tempTaskStartNodeId;
                        taskForm.dataset.to = clickedNodeId;
                        showTaskModal();
                    } else {
                        setMode('add-task-start');
                    }
                    tempTaskStartNodeId = null;
                    break;
                
                case 'set-start':
                    if (clickedNodeId) {
                        startNodeId = clickedNodeId;
                        setMode('view');
                        render();
                    } else {
                        setMode('view');
                    }
                    break;

                case 'set-end':
                    if (clickedNodeId) {
                        endNodeId = clickedNodeId;
                        setMode('view');
                        render();
                    } else {
                        setMode('view');
                    }
                    break;
                
                case 'view':
                    // MUDANÇA: Clicar no vazio no modo 'view' agora des-seleciona tudo
                    if (!clickedNodeId && !e.shiftKey) {
                        selectedNodeIds.clear();
                        render();
                    }
                    break;
            }
        });

        // Handlers do Modal
        taskForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const from = parseInt(taskForm.dataset.from);
            const to = parseInt(taskForm.dataset.to);
            const name = taskNameInput.value;
            const time = parseFloat(taskTimeInput.value);

            if (from && to && name && time >= 0) {
                tasks.push({
                    id: nextTaskId++,
                    from: from,
                    to: to,
                    name: name,
                    time: time,
                    slack: 0,
                    isCritical: false
                });
                hideTaskModal();
                setMode('add-task-start');
                render();
            }
        });

        document.getElementById('cancel-task-btn').addEventListener('click', () => {
            hideTaskModal();
            setMode('add-task-start');
        });
        
        function getSVGPoint(clientX, clientY) {
            const pt = svg.createSVGPoint();
            pt.x = clientX;
            pt.y = clientY;
            return pt.matrixTransform(svg.getScreenCTM().inverse());
        }

        // --- Lógica de Cálculo (CPM) ---

        function calculatePaths() {
            if (!startNodeId || !endNodeId) {
                console.error("Por favor, defina um nó de INÍCIO e um nó de FIM antes de calcular.");
                return false;
            }

            // Reseta os cálculos
            nodes.forEach(n => {
                n.es = 0;
                n.ls = Infinity; // Inicia LS como infinito (exceto para o fim)
                n.isCritical = false;
            });
            tasks.forEach(t => t.isCritical = false);

            const startNode = nodes.find(n => n.id === startNodeId);
            const endNode = nodes.find(n => n.id === endNodeId);
            
            // --- 1. Forward Pass (Cálculo do Tempo Cedo - ES) ---
            let nodePredecessors = {}; 
            nodes.forEach(n => {
                nodePredecessors[n.id] = tasks.filter(t => t.to === n.id).length;
            });
            
            let processQueue = [startNode];
            let visitedCount = 0;

            while(processQueue.length > 0) {
                const u = processQueue.shift();
                visitedCount++;
                
                const outgoingTasks = tasks.filter(t => t.from === u.id);
                
                for(const task of outgoingTasks) {
                    const v = nodes.find(n => n.id === task.to);
                    if (!v) continue; // Nó de destino pode ter sido excluído
                    
                    const newES = u.es + task.time;
                    
                    if (newES > v.es) {
                        v.es = newES;
                    }
                    
                    nodePredecessors[v.id]--;
                    if(nodePredecessors[v.id] === 0) {
                        processQueue.push(v);
                    }
                }
            }

            if (visitedCount < nodes.length) {
                // Tenta encontrar nós não visitados (exclui nós desconectados do início)
                const unvisitedNodes = nodes.filter(n => nodePredecessors[n.id] > 0);
                if (unvisitedNodes.length > 0 && nodes.some(n => n.es === 0 && n.id !== startNodeId)) {
                     console.warn("Aviso: Ciclo detectado ou alguns nós são inalcançáveis a partir do início.");
                     // Não retorna 'false' necessariamente, mas o cálculo pode estar incorreto
                }
            }

            // --- 2. Backward Pass (Cálculo do Tempo Tarde - LS) ---
            const projectDuration = endNode.es;
            endNode.ls = projectDuration;
            
            // Reseta LS para nós inalcançáveis (define como a duração do projeto)
            nodes.forEach(n => {
                if(n.es === 0 && n.id !== startNodeId) {
                    n.ls = projectDuration;
                }
            });
            endNode.ls = projectDuration; // Garante

            // Recalcula sucessores para o backward pass
            let nodeSuccessorsCount = {};
            nodes.forEach(n => {
                nodeSuccessorsCount[n.id] = tasks.filter(t => t.from === n.id).length;
            });

            processQueue = [endNode];
            
            while(processQueue.length > 0) {
                const v = processQueue.shift();
                
                const incomingTasks = tasks.filter(t => t.to === v.id);
                
                for(const task of incomingTasks) {
                    const u = nodes.find(n => n.id === task.from);
                    if (!u) continue;

                    const newLS = v.ls - task.time;
                    
                    if (newLS < u.ls) {
                        u.ls = newLS;
                    }
                    
                    nodeSuccessorsCount[u.id]--;
                    if(nodeSuccessorsCount[u.id] === 0 && u.id !== startNodeId) {
                        processQueue.push(u);
                    }
                    // Garante que o nó inicial seja processado no final
                    if (u.id === startNodeId && nodeSuccessorsCount[u.id] === 0) {
                         if (!processQueue.includes(startNode)) {
                             processQueue.push(startNode);
                         }
                    }
                }
            }
             // Caso especial: se o nó inicial não foi processado (ex: grafo simples A->B)
            if (startNode.ls === Infinity) {
                const taskToStart = tasks.find(t => t.to === startNodeId);
                if (!taskToStart) { // É o nó inicial real
                    const outgoing = tasks.filter(t => t.from === startNodeId);
                    let minLs = Infinity;
                    outgoing.forEach(t => {
                        const nextNode = nodes.find(n => n.id === t.to);
                        if(nextNode) minLs = Math.min(minLs, nextNode.ls - t.time);
                    });
                    startNode.ls = (minLs === Infinity) ? 0 : minLs;
                }
            }
            
            // --- 3. Calcular Folga (Slack) e Caminho Crítico ---
            const tolerance = 1e-5; // Tolerância para comparação de floats
            
            nodes.forEach(n => {
                const slack = n.ls - n.es;
                if (Math.abs(slack) < tolerance && n.es > 0) { // Nó crítico (e alcançável)
                    n.isCritical = true;
                }
                if (n.id === startNodeId && Math.abs(slack) < tolerance) {
                     n.isCritical = true;
                }
                if (n.id === endNodeId) { // Nó final é sempre crítico
                    n.isCritical = true;
                }
            });
            
            tasks.forEach(task => {
                const fromNode = nodes.find(n => n.id === task.from);
                const toNode = nodes.find(n => n.id === task.to);
                if (!fromNode || !toNode) return;

                // Folga da tarefa = LS(fim) - ES(início) - Duração
                const slack = toNode.ls - fromNode.es - task.time;
                task.slack = slack;
                
                if (Math.abs(slack) < tolerance && fromNode.isCritical && toNode.isCritical) {
                    task.isCritical = true;
                }
            });
            
            return true;
        }


        // --- Funções de Import/Export ---
        // (O código de Import/Export existente é mantido aqui)

        // JSON
        document.getElementById('export-json-btn').addEventListener('click', () => {
            const data = {
                nodes,
                tasks,
                nextNodeId,
                nextTaskId,
                startNodeId,
                endNodeId
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            saveAs(blob, 'projeto-rede-tarefas.json');
        });

        document.getElementById('import-json-btn').addEventListener('click', () => {
            fileInput.click();
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const data = JSON.parse(event.target.result);
                    nodes = data.nodes || [];
                    tasks = data.tasks || [];
                    nextNodeId = data.nextNodeId || 1;
                    nextTaskId = data.nextTaskId || 1;
                    startNodeId = data.startNodeId || null;
                    endNodeId = data.endNodeId || null;
                    selectedNodeIds.clear(); // Limpa seleção ao importar
                    render();
                    setMode('view');
                } catch (err) {
                    console.error("Erro ao ler o arquivo JSON: " + err.message);
                }
            };
            reader.readAsText(file);
            fileInput.value = null; // Reseta o input
        });

        // --- Lógica de Exportação de SVG (Com Estilos) ---
        
        // Função auxiliar para copiar estilos
        function getClonedSvgWithStyles() {
            const clonedSvg = svg.cloneNode(true);
            clonedSvg.setAttribute('width', svg.clientWidth);
            clonedSvg.setAttribute('height', svg.clientHeight);

            const styleDef = document.createElementNS('http://www.w3.org/2000/svg', 'style');
            
            // 1. Pega os estilos da tag <style>
            const styleElement = document.getElementById('pert-svg-styles');
            if (styleElement) {
                styleDef.textContent = styleElement.innerHTML;
            }
            
            // 2. MUDANÇA: Adiciona manualmente a fonte, pois o SVG exportado pode perdê-la
            styleDef.textContent += `
                svg { 
                    font-family: 'Inter', sans-serif; 
                }
                .task-text {
                    /* Garante que a sombra seja aplicada no SVG exportado */
                    text-shadow: 0 0 3px #fff, 0 0 3px #fff, 0 0 3px #fff;
                }
            `;
            
            clonedSvg.querySelector('defs').appendChild(styleDef);
            return clonedSvg;
        }

        // SVG
        document.getElementById('export-svg-btn').addEventListener('click', () => {
            if (typeof saveAs === 'undefined') {
                console.error("Erro: Biblioteca FileSaver.js não carregada.");
                return;
            }
            const clonedSvg = getClonedSvgWithStyles();
            const svgData = new XMLSerializer().serializeToString(clonedSvg);
            const blob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
            saveAs(blob, 'diagrama-rede.svg');
        });

        // --- Inicialização ---
        setMode('view');
        render();

    </script>
</body>
</html>

